const sqlite3 = require('sqlite3').verbose();
const path = require('path');
const fs = require('fs');
const logger = require('../utils/logger');

class DatabaseRepair {
    constructor(dbPath) {
        this.dbPath = dbPath || path.join(__dirname, '../data/chat.db');
        this.db = null;
        this.backupPath = null;
    }

    // ÂàùÂßãÂåñ‰øÆÂæ©ÈÅéÁ®ã
    async init() {
        try {
            console.log('üîß ÈñãÂßãÊï∏ÊìöÂ∫´‰øÆÂæ©ÈÅéÁ®ã...');

            // ÂâµÂª∫ÂÇô‰ªΩ
            await this.createBackup();

            // ÈÄ£Êé•Êï∏ÊìöÂ∫´
            await this.connectDatabase();

            // Ê™¢Êü•Êï∏ÊìöÂ∫´ÂÆåÊï¥ÊÄß
            await this.checkIntegrity();

            // ‰øÆÂæ©Ë°®ÁµêÊßã
            await this.repairTables();

            // ‰øÆÂæ©Á¥¢Âºï
            await this.repairIndexes();

            // ‰øÆÂæ©Êï∏Êìö‰∏ÄËá¥ÊÄß
            await this.repairDataConsistency();

            // ÂÑ™ÂåñÊï∏ÊìöÂ∫´
            await this.optimizeDatabase();

            console.log('‚úÖ Êï∏ÊìöÂ∫´‰øÆÂæ©ÂÆåÊàê');

        } catch (error) {
            console.error('‚ùå Êï∏ÊìöÂ∫´‰øÆÂæ©Â§±Êïó:', error);

            // ÂòóË©¶ÂæûÂÇô‰ªΩÊÅ¢Âæ©
            if (this.backupPath) {
                await this.restoreFromBackup();
            }

            throw error;
        } finally {
            if (this.db) {
                this.db.close();
            }
        }
    }

    // ÂâµÂª∫Êï∏ÊìöÂ∫´ÂÇô‰ªΩ
    async createBackup() {
        return new Promise((resolve, reject) => {
            try {
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                this.backupPath = `${this.dbPath}.backup.${timestamp}`;

                if (fs.existsSync(this.dbPath)) {
                    fs.copyFileSync(this.dbPath, this.backupPath);
                    console.log(`üìÅ Êï∏ÊìöÂ∫´ÂÇô‰ªΩÂ∑≤ÂâµÂª∫: ${this.backupPath}`);
                } else {
                    console.log('üìÅ Êï∏ÊìöÂ∫´Êñá‰ª∂‰∏çÂ≠òÂú®ÔºåÂ∞áÂâµÂª∫Êñ∞ÁöÑÊï∏ÊìöÂ∫´');
                }

                resolve();
            } catch (error) {
                reject(error);
            }
        });
    }

    // ÈÄ£Êé•Êï∏ÊìöÂ∫´
    async connectDatabase() {
        return new Promise((resolve, reject) => {
            // Á¢∫‰øùÊï∏ÊìöÁõÆÈåÑÂ≠òÂú®
            const dataDir = path.dirname(this.dbPath);
            if (!fs.existsSync(dataDir)) {
                fs.mkdirSync(dataDir, { recursive: true });
            }

            this.db = new sqlite3.Database(this.dbPath, (err) => {
                if (err) {
                    reject(err);
                } else {
                    console.log('üîó Êï∏ÊìöÂ∫´ÈÄ£Êé•ÊàêÂäü');

                    // ÂïüÁî®Â§ñÈçµÁ¥ÑÊùü
                    this.db.run('PRAGMA foreign_keys = ON');

                    resolve();
                }
            });
        });
    }

    // Ê™¢Êü•Êï∏ÊìöÂ∫´ÂÆåÊï¥ÊÄß
    async checkIntegrity() {
        return new Promise((resolve, reject) => {
            this.db.get('PRAGMA integrity_check', (err, row) => {
                if (err) {
                    reject(err);
                } else {
                    if (row && row.integrity_check === 'ok') {
                        console.log('‚úÖ Êï∏ÊìöÂ∫´ÂÆåÊï¥ÊÄßÊ™¢Êü•ÈÄöÈÅé');
                    } else {
                        console.warn('‚ö†Ô∏è Êï∏ÊìöÂ∫´ÂÆåÊï¥ÊÄßÊ™¢Êü•ÁôºÁèæÂïèÈ°å:', row);
                    }
                    resolve();
                }
            });
        });
    }

    // ‰øÆÂæ©Ë°®ÁµêÊßã
    async repairTables() {
        console.log('üî® ‰øÆÂæ©Ë°®ÁµêÊßã...');

        const tables = this.getTableDefinitions();

        for (const tableDef of tables) {
            try {
                await this.createOrUpdateTable(tableDef);
            } catch (error) {
                console.error(`‰øÆÂæ©Ë°® ${tableDef.name} Â§±Êïó:`, error);
            }
        }
    }

    // Áç≤ÂèñË°®ÂÆöÁæ©
    getTableDefinitions() {
        return [
            {
                name: 'users',
                sql: `CREATE TABLE IF NOT EXISTS users (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    uuid TEXT UNIQUE NOT NULL,
                    username TEXT UNIQUE NOT NULL,
                    email TEXT UNIQUE NOT NULL,
                    password_hash TEXT NOT NULL,
                    avatar TEXT,
                    status TEXT DEFAULT 'offline',
                    is_verified BOOLEAN DEFAULT FALSE,
                    is_admin BOOLEAN DEFAULT FALSE,
                    last_seen_at DATETIME,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )`
            },
            {
                name: 'rooms',
                sql: `CREATE TABLE IF NOT EXISTS rooms (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    uuid TEXT UNIQUE NOT NULL,
                    name TEXT NOT NULL,
                    description TEXT,
                    type TEXT DEFAULT 'public',
                    max_members INTEGER DEFAULT 100,
                    password_hash TEXT,
                    avatar TEXT,
                    owner_uuid TEXT NOT NULL,
                    is_active BOOLEAN DEFAULT TRUE,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (owner_uuid) REFERENCES users(uuid) ON DELETE CASCADE
                )`
            },
            {
                name: 'room_members',
                sql: `CREATE TABLE IF NOT EXISTS room_members (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    room_uuid TEXT NOT NULL,
                    user_uuid TEXT NOT NULL,
                    role TEXT DEFAULT 'member',
                    joined_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    last_read_at DATETIME,
                    is_muted BOOLEAN DEFAULT FALSE,
                    FOREIGN KEY (room_uuid) REFERENCES rooms(uuid) ON DELETE CASCADE,
                    FOREIGN KEY (user_uuid) REFERENCES users(uuid) ON DELETE CASCADE,
                    UNIQUE(room_uuid, user_uuid)
                )`
            },
            {
                name: 'messages',
                sql: `CREATE TABLE IF NOT EXISTS messages (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    uuid TEXT UNIQUE NOT NULL,
                    room_uuid TEXT NOT NULL,
                    sender_uuid TEXT NOT NULL,
                    type TEXT DEFAULT 'text',
                    content TEXT NOT NULL,
                    reply_to_uuid TEXT,
                    edited_at DATETIME,
                    is_deleted BOOLEAN DEFAULT FALSE,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (room_uuid) REFERENCES rooms(uuid) ON DELETE CASCADE,
                    FOREIGN KEY (sender_uuid) REFERENCES users(uuid) ON DELETE CASCADE,
                    FOREIGN KEY (reply_to_uuid) REFERENCES messages(uuid) ON DELETE SET NULL
                )`
            },
            {
                name: 'files',
                sql: `CREATE TABLE IF NOT EXISTS files (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    uuid TEXT UNIQUE NOT NULL,
                    message_uuid TEXT NOT NULL,
                    filename TEXT NOT NULL,
                    original_name TEXT NOT NULL,
                    mime_type TEXT NOT NULL,
                    size INTEGER NOT NULL,
                    path TEXT NOT NULL,
                    thumbnail_path TEXT,
                    uploaded_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (message_uuid) REFERENCES messages(uuid) ON DELETE CASCADE
                )`
            },
            {
                name: 'sessions',
                sql: `CREATE TABLE IF NOT EXISTS sessions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    session_id TEXT UNIQUE NOT NULL,
                    user_uuid TEXT NOT NULL,
                    ip_address TEXT,
                    user_agent TEXT,
                    expires_at DATETIME NOT NULL,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_uuid) REFERENCES users(uuid) ON DELETE CASCADE
                )`
            },
            {
                name: 'notifications',
                sql: `CREATE TABLE IF NOT EXISTS notifications (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    uuid TEXT UNIQUE NOT NULL,
                    user_uuid TEXT NOT NULL,
                    type TEXT NOT NULL,
                    title TEXT NOT NULL,
                    content TEXT,
                    data TEXT,
                    is_read BOOLEAN DEFAULT FALSE,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_uuid) REFERENCES users(uuid) ON DELETE CASCADE
                )`
            },
            {
                name: 'settings',
                sql: `CREATE TABLE IF NOT EXISTS settings (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    key TEXT UNIQUE NOT NULL,
                    value TEXT NOT NULL,
                    type TEXT DEFAULT 'string',
                    description TEXT,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )`
            },
            {
                name: 'audit_logs',
                sql: `CREATE TABLE IF NOT EXISTS audit_logs (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_uuid TEXT,
                    action TEXT NOT NULL,
                    resource_type TEXT,
                    resource_id TEXT,
                    ip_address TEXT,
                    user_agent TEXT,
                    details TEXT,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_uuid) REFERENCES users(uuid) ON DELETE SET NULL
                )`
            }
        ];
    }

    // ÂâµÂª∫ÊàñÊõ¥Êñ∞Ë°®
    async createOrUpdateTable(tableDef) {
        return new Promise((resolve, reject) => {
            this.db.run(tableDef.sql, (err) => {
                if (err) {
                    reject(err);
                } else {
                    console.log(`‚úÖ Ë°® ${tableDef.name} ÂâµÂª∫/Êõ¥Êñ∞ÊàêÂäü`);
                    resolve();
                }
            });
        });
    }

    // ‰øÆÂæ©Á¥¢Âºï
    async repairIndexes() {
        console.log('üî® ‰øÆÂæ©Á¥¢Âºï...');

        const indexes = this.getIndexDefinitions();

        for (const indexDef of indexes) {
            try {
                await this.createIndex(indexDef);
            } catch (error) {
                console.error(`ÂâµÂª∫Á¥¢Âºï ${indexDef.name} Â§±Êïó:`, error);
            }
        }
    }

    // Áç≤ÂèñÁ¥¢ÂºïÂÆöÁæ©
    getIndexDefinitions() {
        return [
            {
                name: 'idx_users_username',
                sql: 'CREATE UNIQUE INDEX IF NOT EXISTS idx_users_username ON users(username)'
            },
            {
                name: 'idx_users_email',
                sql: 'CREATE UNIQUE INDEX IF NOT EXISTS idx_users_email ON users(email)'
            },
            {
                name: 'idx_users_uuid',
                sql: 'CREATE UNIQUE INDEX IF NOT EXISTS idx_users_uuid ON users(uuid)'
            },
            {
                name: 'idx_rooms_uuid',
                sql: 'CREATE UNIQUE INDEX IF NOT EXISTS idx_rooms_uuid ON rooms(uuid)'
            },
            {
                name: 'idx_rooms_owner',
                sql: 'CREATE INDEX IF NOT EXISTS idx_rooms_owner ON rooms(owner_uuid)'
            },
            {
                name: 'idx_room_members_room',
                sql: 'CREATE INDEX IF NOT EXISTS idx_room_members_room ON room_members(room_uuid)'
            },
            {
                name: 'idx_room_members_user',
                sql: 'CREATE INDEX IF NOT EXISTS idx_room_members_user ON room_members(user_uuid)'
            },
            {
                name: 'idx_messages_uuid',
                sql: 'CREATE UNIQUE INDEX IF NOT EXISTS idx_messages_uuid ON messages(uuid)'
            },
            {
                name: 'idx_messages_room',
                sql: 'CREATE INDEX IF NOT EXISTS idx_messages_room ON messages(room_uuid)'
            },
            {
                name: 'idx_messages_sender',
                sql: 'CREATE INDEX IF NOT EXISTS idx_messages_sender ON messages(sender_uuid)'
            },
            {
                name: 'idx_messages_created',
                sql: 'CREATE INDEX IF NOT EXISTS idx_messages_created ON messages(created_at)'
            },
            {
                name: 'idx_files_message',
                sql: 'CREATE INDEX IF NOT EXISTS idx_files_message ON files(message_uuid)'
            },
            {
                name: 'idx_sessions_user',
                sql: 'CREATE INDEX IF NOT EXISTS idx_sessions_user ON sessions(user_uuid)'
            },
            {
                name: 'idx_sessions_expires',
                sql: 'CREATE INDEX IF NOT EXISTS idx_sessions_expires ON sessions(expires_at)'
            },
            {
                name: 'idx_notifications_user',
                sql: 'CREATE INDEX IF NOT EXISTS idx_notifications_user ON notifications(user_uuid)'
            },
            {
                name: 'idx_audit_logs_user',
                sql: 'CREATE INDEX IF NOT EXISTS idx_audit_logs_user ON audit_logs(user_uuid)'
            },
            {
                name: 'idx_audit_logs_created',
                sql: 'CREATE INDEX IF NOT EXISTS idx_audit_logs_created ON audit_logs(created_at)'
            }
        ];
    }

    // ÂâµÂª∫Á¥¢Âºï
    async createIndex(indexDef) {
        return new Promise((resolve, reject) => {
            this.db.run(indexDef.sql, (err) => {
                if (err) {
                    reject(err);
                } else {
                    console.log(`‚úÖ Á¥¢Âºï ${indexDef.name} ÂâµÂª∫ÊàêÂäü`);
                    resolve();
                }
            });
        });
    }

    // ‰øÆÂæ©Êï∏Êìö‰∏ÄËá¥ÊÄß
    async repairDataConsistency() {
        console.log('üî® ‰øÆÂæ©Êï∏Êìö‰∏ÄËá¥ÊÄß...');

        try {
            // Ê∏ÖÁêÜÈÅéÊúüÊúÉË©±
            await this.cleanExpiredSessions();

            // ‰øÆÂæ©Â≠§Á´ãÊï∏Êìö
            await this.cleanOrphanedData();

            // ‰øÆÂæ©Áî®Êà∂ÁãÄÊÖã
            await this.repairUserStatuses();

            // Ê∏ÖÁêÜÁÑ°ÊïàÊñá‰ª∂ÂºïÁî®
            await this.cleanInvalidFileReferences();

        } catch (error) {
            console.error('Êï∏Êìö‰∏ÄËá¥ÊÄß‰øÆÂæ©Â§±Êïó:', error);
            throw error;
        }
    }

    // Ê∏ÖÁêÜÈÅéÊúüÊúÉË©±
    async cleanExpiredSessions() {
        return new Promise((resolve, reject) => {
            this.db.run(
                'DELETE FROM sessions WHERE expires_at < datetime("now")',
                (err) => {
                    if (err) {
                        reject(err);
                    } else {
                        console.log(`‚úÖ Ê∏ÖÁêÜÈÅéÊúüÊúÉË©±: ${this.changes} Ê¢ùË®òÈåÑ`);
                        resolve();
                    }
                }
            );
        });
    }

    // Ê∏ÖÁêÜÂ≠§Á´ãÊï∏Êìö
    async cleanOrphanedData() {
        const cleanupQueries = [
            {
                name: 'Ê∏ÖÁêÜÂ≠§Á´ãÊàøÈñìÊàêÂì°',
                sql: `DELETE FROM room_members 
                      WHERE user_uuid NOT IN (SELECT uuid FROM users)
                      OR room_uuid NOT IN (SELECT uuid FROM rooms)`
            },
            {
                name: 'Ê∏ÖÁêÜÂ≠§Á´ãÊ∂àÊÅØ',
                sql: `DELETE FROM messages 
                      WHERE sender_uuid NOT IN (SELECT uuid FROM users)
                      OR room_uuid NOT IN (SELECT uuid FROM rooms)`
            },
            {
                name: 'Ê∏ÖÁêÜÂ≠§Á´ãÊñá‰ª∂',
                sql: `DELETE FROM files 
                      WHERE message_uuid NOT IN (SELECT uuid FROM messages)`
            },
            {
                name: 'Ê∏ÖÁêÜÂ≠§Á´ãÈÄöÁü•',
                sql: `DELETE FROM notifications 
                      WHERE user_uuid NOT IN (SELECT uuid FROM users)`
            }
        ];

        for (const query of cleanupQueries) {
            try {
                await new Promise((resolve, reject) => {
                    this.db.run(query.sql, function(err) {
                        if (err) {
                            reject(err);
                        } else {
                            console.log(`‚úÖ ${query.name}: ${this.changes} Ê¢ùË®òÈåÑ`);
                            resolve();
                        }
                    });
                });
            } catch (error) {
                console.error(`${query.name} Â§±Êïó:`, error);
            }
        }
    }

    // ‰øÆÂæ©Áî®Êà∂ÁãÄÊÖã
    async repairUserStatuses() {
        return new Promise((resolve, reject) => {
            // Â∞áÊâÄÊúâÈùûÊ¥ªÂãïÁî®Êà∂Ë®≠ÁÇ∫Èõ¢Á∑ö
            this.db.run(
                `UPDATE users SET status = 'offline' 
                 WHERE status != 'offline' 
                 AND last_seen_at < datetime('now', '-5 minutes')`,
                function(err) {
                    if (err) {
                        reject(err);
                    } else {
                        console.log(`‚úÖ ‰øÆÂæ©Áî®Êà∂ÁãÄÊÖã: ${this.changes} Ê¢ùË®òÈåÑ`);
                        resolve();
                    }
                }
            );
        });
    }

    // Ê∏ÖÁêÜÁÑ°ÊïàÊñá‰ª∂ÂºïÁî®
    async cleanInvalidFileReferences() {
        return new Promise((resolve, reject) => {
            this.db.all(
                'SELECT uuid, path FROM files',
                async (err, rows) => {
                    if (err) {
                        reject(err);
                        return;
                    }

                    let deletedCount = 0;
                    for (const row of rows) {
                        if (!fs.existsSync(row.path)) {
                            try {
                                await new Promise((res, rej) => {
                                    this.db.run(
                                        'DELETE FROM files WHERE uuid = ?',
                                        [row.uuid],
                                        function(deleteErr) {
                                            if (deleteErr) rej(deleteErr);
                                            else {
                                                deletedCount++;
                                                res();
                                            }
                                        }
                                    );
                                });
                            } catch (deleteError) {
                                console.error(`Âà™Èô§ÁÑ°ÊïàÊñá‰ª∂Ë®òÈåÑÂ§±Êïó: ${row.uuid}`, deleteError);
                            }
                        }
                    }

                    console.log(`‚úÖ Ê∏ÖÁêÜÁÑ°ÊïàÊñá‰ª∂ÂºïÁî®: ${deletedCount} Ê¢ùË®òÈåÑ`);
                    resolve();
                }
            );
        });
    }

    // ÂÑ™ÂåñÊï∏ÊìöÂ∫´
    async optimizeDatabase() {
        console.log('üî® ÂÑ™ÂåñÊï∏ÊìöÂ∫´...');

        const optimizations = [
            { name: 'ANALYZE', sql: 'ANALYZE' },
            { name: 'VACUUM', sql: 'VACUUM' },
            { name: 'REINDEX', sql: 'REINDEX' }
        ];

        for (const opt of optimizations) {
            try {
                await new Promise((resolve, reject) => {
                    this.db.run(opt.sql, (err) => {
                        if (err) {
                            reject(err);
                        } else {
                            console.log(`‚úÖ ${opt.name} ÂÆåÊàê`);
                            resolve();
                        }
                    });
                });
            } catch (error) {
                console.error(`${opt.name} Â§±Êïó:`, error);
            }
        }
    }

    // ÊèíÂÖ•ÈªòË™çË®≠ÁΩÆ
    async insertDefaultSettings() {
        console.log('üî® ÊèíÂÖ•ÈªòË™çË®≠ÁΩÆ...');

        const defaultSettings = [
            ['site_name', 'Elite Chat App', 'string', 'Á∂≤Á´ôÂêçÁ®±'],
            ['max_file_size', '10485760', 'number', 'ÊúÄÂ§ßÊñá‰ª∂Â§ßÂ∞èÔºàÂ≠óÁØÄÔºâ'],
            ['allowed_file_types', 'image/jpeg,image/png,image/gif,text/plain,application/pdf', 'string', 'ÂÖÅË®±ÁöÑÊñá‰ª∂È°ûÂûã'],
            ['max_message_length', '1000', 'number', 'ÊúÄÂ§ßË®äÊÅØÈï∑Â∫¶'],
            ['registration_enabled', 'true', 'boolean', 'ÊòØÂê¶ÂÖÅË®±Ë®ªÂÜä'],
            ['email_verification_required', 'false', 'boolean', 'ÊòØÂê¶ÈúÄË¶ÅÈÉµÁÆ±È©óË≠â'],
            ['rate_limit_messages', '60', 'number', 'ÊØèÂàÜÈêòÊúÄÂ§ßË®äÊÅØÊï∏'],
            ['rate_limit_uploads', '10', 'number', 'ÊØèÂàÜÈêòÊúÄÂ§ß‰∏äÂÇ≥Êï∏'],
            ['default_theme', 'light', 'string', 'ÈªòË™ç‰∏ªÈ°å'],
            ['welcome_message', 'Ê≠°ËøéÂä†ÂÖ• Elite ChatÔºÅ', 'string', 'Ê≠°ËøéË®äÊÅØ'],
            ['maintenance_mode', 'false', 'boolean', 'Á∂≠Ë≠∑Ê®°Âºè'],
            ['guest_access_enabled', 'false', 'boolean', 'ÊòØÂê¶ÂÖÅË®±Ë®™ÂÆ¢Ë®™Âïè'],
            ['max_room_members', '100', 'number', 'ÊàøÈñìÊúÄÂ§ßÊàêÂì°Êï∏'],
            ['message_retention_days', '365', 'number', 'Ê∂àÊÅØ‰øùÁïôÂ§©Êï∏'],
            ['session_timeout_minutes', '1440', 'number', 'ÊúÉË©±Ë∂ÖÊôÇÊôÇÈñìÔºàÂàÜÈêòÔºâ']
        ];

        const insertPromises = defaultSettings.map(setting => {
            return new Promise((resolve, reject) => {
                this.db.run(
                    `INSERT OR IGNORE INTO settings (key, value, type, description) 
                     VALUES (?, ?, ?, ?)`,
                    setting,
                    function(err) {
                        if (err) {
                            reject(err);
                        } else {
                            if (this.changes > 0) {
                                console.log(`‚úÖ ÊèíÂÖ•Ë®≠ÁΩÆ: ${setting[0]}`);
                            }
                            resolve();
                        }
                    }
                );
            });
        });

        try {
            await Promise.all(insertPromises);
            console.log('‚úÖ ÈªòË™çË®≠ÁΩÆÊèíÂÖ•ÂÆåÊàê');
        } catch (error) {
            console.error('ÊèíÂÖ•ÈªòË™çË®≠ÁΩÆÂ§±Êïó:', error);
            throw error;
        }
    }

    // ÂâµÂª∫ÁÆ°ÁêÜÂì°Áî®Êà∂
    async createAdminUser() {
        console.log('üî® Ê™¢Êü•ÁÆ°ÁêÜÂì°Áî®Êà∂...');

        return new Promise((resolve, reject) => {
            // Ê™¢Êü•ÊòØÂê¶Â∑≤Â≠òÂú®ÁÆ°ÁêÜÂì°
            this.db.get(
                'SELECT COUNT(*) as count FROM users WHERE is_admin = TRUE',
                (err, row) => {
                    if (err) {
                        reject(err);
                        return;
                    }

                    if (row.count > 0) {
                        console.log('‚úÖ ÁÆ°ÁêÜÂì°Áî®Êà∂Â∑≤Â≠òÂú®');
                        resolve();
                        return;
                    }

                    // ÂâµÂª∫ÈªòË™çÁÆ°ÁêÜÂì°
                    const bcrypt = require('bcrypt');
                    const { v4: uuidv4 } = require('uuid');

                    const adminData = {
                        uuid: uuidv4(),
                        username: 'admin',
                        email: 'admin@elitechat.com',
                        password: 'admin123', // ÊáâË©≤Âú®È¶ñÊ¨°ÁôªÈåÑÊôÇË¶ÅÊ±ÇÊõ¥Êîπ
                        isAdmin: true
                    };

                    bcrypt.hash(adminData.password, 10, (hashErr, hash) => {
                        if (hashErr) {
                            reject(hashErr);
                            return;
                        }

                        this.db.run(
                            `INSERT INTO users (uuid, username, email, password_hash, is_admin, status, created_at)
                             VALUES (?, ?, ?, ?, ?, 'offline', CURRENT_TIMESTAMP)`,
                            [adminData.uuid, adminData.username, adminData.email, hash, adminData.isAdmin],
                            function(insertErr) {
                                if (insertErr) {
                                    reject(insertErr);
                                } else {
                                    console.log('‚úÖ ÈªòË™çÁÆ°ÁêÜÂì°Áî®Êà∂Â∑≤ÂâµÂª∫');
                                    console.log('‚ö†Ô∏è  Ë´ã‰ΩøÁî®‰ª•‰∏ãÊÜëË≠âÁôªÈåÑ‰∏¶Á´ãÂç≥Êõ¥ÊîπÂØÜÁ¢º:');
                                    console.log(`   Áî®Êà∂Âêç: ${adminData.username}`);
                                    console.log(`   ÂØÜÁ¢º: ${adminData.password}`);
                                    resolve();
                                }
                            }
                        );
                    });
                }
            );
        });
    }

    // ÂæûÂÇô‰ªΩÊÅ¢Âæ©
    async restoreFromBackup() {
        if (!this.backupPath || !fs.existsSync(this.backupPath)) {
            throw new Error('ÂÇô‰ªΩÊñá‰ª∂‰∏çÂ≠òÂú®ÔºåÁÑ°Ê≥ïÊÅ¢Âæ©');
        }

        try {
            console.log('üîÑ ÂæûÂÇô‰ªΩÊÅ¢Âæ©Êï∏ÊìöÂ∫´...');

            if (this.db) {
                this.db.close();
            }

            fs.copyFileSync(this.backupPath, this.dbPath);
            console.log('‚úÖ Êï∏ÊìöÂ∫´Â∑≤ÂæûÂÇô‰ªΩÊÅ¢Âæ©');

        } catch (error) {
            console.error('ÂæûÂÇô‰ªΩÊÅ¢Âæ©Â§±Êïó:', error);
            throw error;
        }
    }

    // ÁîüÊàê‰øÆÂæ©Â†±Âëä
    async generateRepairReport() {
        const report = {
            timestamp: new Date().toISOString(),
            databasePath: this.dbPath,
            backupPath: this.backupPath,
            tables: {},
            indexes: {},
            statistics: {}
        };

        try {
            // Áç≤ÂèñË°®‰ø°ÊÅØ
            const tables = await new Promise((resolve, reject) => {
                this.db.all(
                    "SELECT name FROM sqlite_master WHERE type='table'",
                    (err, rows) => {
                        if (err) reject(err);
                        else resolve(rows);
                    }
                );
            });

            for (const table of tables) {
                const count = await new Promise((resolve, reject) => {
                    this.db.get(
                        `SELECT COUNT(*) as count FROM ${table.name}`,
                        (err, row) => {
                            if (err) reject(err);
                            else resolve(row.count);
                        }
                    );
                });
                report.tables[table.name] = count;
            }

            // Áç≤ÂèñÁ¥¢Âºï‰ø°ÊÅØ
            const indexes = await new Promise((resolve, reject) => {
                this.db.all(
                    "SELECT name FROM sqlite_master WHERE type='index'",
                    (err, rows) => {
                        if (err) reject(err);
                        else resolve(rows);
                    }
                );
            });

            report.indexes.count = indexes.length;
            report.indexes.names = indexes.map(idx => idx.name);

            // Áç≤ÂèñÊï∏ÊìöÂ∫´Áµ±Ë®à
            const dbSize = fs.statSync(this.dbPath).size;
            report.statistics.databaseSize = dbSize;
            report.statistics.totalTables = Object.keys(report.tables).length;
            report.statistics.totalRecords = Object.values(report.tables).reduce((sum, count) => sum + count, 0);

            console.log('üìä ‰øÆÂæ©Â†±Âëä:');
            console.log(JSON.stringify(report, null, 2));

            return report;

        } catch (error) {
            console.error('ÁîüÊàê‰øÆÂæ©Â†±ÂëäÂ§±Êïó:', error);
            throw error;
        }
    }

    // Ê∏ÖÁêÜËàäÂÇô‰ªΩÊñá‰ª∂
    static cleanOldBackups(dbPath, keepDays = 7) {
        try {
            const dataDir = path.dirname(dbPath);
            const dbName = path.basename(dbPath);
            const files = fs.readdirSync(dataDir);

            const backupFiles = files.filter(file =>
                file.startsWith(`${dbName}.backup.`) &&
                file.match(/\d{4}-\d{2}-\d{2}T\d{2}-\d{2}-\d{2}/)
            );

            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - keepDays);

            let deletedCount = 0;
            backupFiles.forEach(file => {
                const filePath = path.join(dataDir, file);
                const stats = fs.statSync(filePath);

                if (stats.mtime < cutoffDate) {
                    fs.unlinkSync(filePath);
                    deletedCount++;
                }
            });

            if (deletedCount > 0) {
                console.log(`üóëÔ∏è  Ê∏ÖÁêÜ‰∫Ü ${deletedCount} ÂÄãËàäÂÇô‰ªΩÊñá‰ª∂`);
            }

        } catch (error) {
            console.error('Ê∏ÖÁêÜËàäÂÇô‰ªΩÊñá‰ª∂Â§±Êïó:', error);
        }
    }
}

// ‰∏ª‰øÆÂæ©ÂáΩÊï∏
async function repairDatabase(dbPath) {
    const repair = new DatabaseRepair(dbPath);

    try {
        await repair.init();
        await repair.insertDefaultSettings();
        await repair.createAdminUser();

        const report = await repair.generateRepairReport();

        // Ê∏ÖÁêÜËàäÂÇô‰ªΩ
        DatabaseRepair.cleanOldBackups(dbPath);

        return {
            success: true,
            report: report,
            message: 'Êï∏ÊìöÂ∫´‰øÆÂæ©ÂÆåÊàê'
        };

    } catch (error) {
        return {
            success: false,
            error: error.message,
            message: 'Êï∏ÊìöÂ∫´‰øÆÂæ©Â§±Êïó'
        };
    }
}

// ÂëΩ‰ª§Ë°åÂ∑•ÂÖ∑
if (require.main === module) {
    const dbPath = process.argv[2] || path.join(__dirname, '../data/chat.db');

    console.log('üöÄ ÈñãÂßãÊï∏ÊìöÂ∫´‰øÆÂæ©...');
    console.log(`üìÅ Êï∏ÊìöÂ∫´Ë∑ØÂæë: ${dbPath}`);

    repairDatabase(dbPath)
        .then(result => {
            if (result.success) {
                console.log('‚úÖ ‰øÆÂæ©ÊàêÂäü:', result.message);
                process.exit(0);
            } else {
                console.error('‚ùå ‰øÆÂæ©Â§±Êïó:', result.message);
                console.error('ÈåØË™§Ë©≥ÊÉÖ:', result.error);
                process.exit(1);
            }
        })
        .catch(error => {
            console.error('üí• ‰øÆÂæ©ÈÅéÁ®ã‰∏≠ÁôºÁîüÈåØË™§:', error);
            process.exit(1);
        });
}

module.exports = {
    DatabaseRepair,
    repairDatabase
};